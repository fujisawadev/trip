"""sync_with_staging

Revision ID: 224c661d1d75
Revises: merge_heads_20250411
Create Date: 2025-04-11 23:12:52.304357

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql
from sqlalchemy.sql import text
import logging

# revision identifiers, used by Alembic.
revision = '224c661d1d75'
down_revision = 'merge_heads_20250411'
branch_labels = None
depends_on = None

logger = logging.getLogger('alembic.migration')

def column_exists(table, column):
    """指定されたカラムがテーブルに存在するかチェック"""
    bind = op.get_bind()
    conn = bind.connect()
    try:
        # PostgreSQLのinformation_schemaからカラムの存在を確認
        result = conn.execute(
            text(
                "SELECT EXISTS (SELECT 1 FROM information_schema.columns "
                "WHERE table_name = :table AND column_name = :column)"
            ),
            {"table": table, "column": column}
        ).scalar()
        return result
    except Exception as e:
        logger.warning(f"カラム存在チェックでエラーが発生: {e}")
        return False
    finally:
        conn.close()

def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    # 索引の整理（ステージング環境との整合性を保つため）
    connection = op.get_bind()
    
    try:
        # NULL値を持つユーザーを一時的に更新
        connection.execute(text("UPDATE users SET username = 'user_' || id WHERE username IS NULL"))
        logger.info("NULL値のユーザー名を一時的な値に更新しました")
        
        connection.execute(text("UPDATE users SET email = 'user_' || id || '@example.com' WHERE email IS NULL"))
        logger.info("NULL値のメールアドレスを一時的な値に更新しました")
        
        # 次に送信メッセージのインデックスを整理
        if connection.execute(text("SELECT 1 FROM pg_indexes WHERE indexname = 'ix_sender_recipient'")).scalar():
            op.drop_index('ix_sender_recipient', table_name='sent_messages')
            logger.info("ix_sender_recipient インデックスを削除しました")
    except Exception as e:
        logger.warning(f"インデックス削除中にエラーが発生: {e}")

    # reset_token と reset_password_token の整合性を取る
    # ステージング環境はreset_tokenを使用、ローカルはreset_password_tokenを使用
    try:
        # reset_token を追加（既に存在する場合はスキップ）
        if not column_exists('users', 'reset_token'):
            op.add_column('users', sa.Column('reset_token', sa.String(100), nullable=True))
            # 既存のデータを移行
            connection.execute(text("UPDATE users SET reset_token = reset_password_token"))
            logger.info("reset_token カラムを追加し、データを移行しました")
        
        # reset_token_expires_at を追加（既に存在する場合はスキップ）
        if not column_exists('users', 'reset_token_expires_at'):
            op.add_column('users', sa.Column('reset_token_expires_at', sa.DateTime(), nullable=True))
            # 既存のデータを移行
            connection.execute(text("UPDATE users SET reset_token_expires_at = reset_password_expires"))
            logger.info("reset_token_expires_at カラムを追加し、データを移行しました")
    except Exception as e:
        logger.warning(f"リセットトークン関連カラムの追加中にエラーが発生: {e}")

    # NOT NULL制約とユニーク制約を整理（ステージング環境と合わせる）
    try:
        # usernameとemailのNOT NULL制約を設定（ステージング環境と一致させる）
        op.alter_column('users', 'username', existing_type=sa.VARCHAR(length=64), nullable=False)
        op.alter_column('users', 'email', existing_type=sa.VARCHAR(length=120), nullable=False)
        logger.info("usernameとemailのNOT NULL制約を設定しました")
        
        # ユニーク制約を整理
        # 既存のインデックスを削除し、新しいユニーク制約を追加
        # この処理は条件付きで行う必要がある（既にある場合はスキップ）
        
        # インデックスの存在確認と削除
        if connection.execute(text("SELECT 1 FROM pg_indexes WHERE indexname = 'ix_users_email'")).scalar():
            op.drop_index('ix_users_email', table_name='users')
            logger.info("ix_users_email インデックスを削除しました")
        
        if connection.execute(text("SELECT 1 FROM pg_indexes WHERE indexname = 'ix_users_username'")).scalar():
            op.drop_index('ix_users_username', table_name='users')
            logger.info("ix_users_username インデックスを削除しました")
        
        # インデックスを再作成（ステージング環境と同じ名前で）
        op.create_index('ix_users_email', 'users', ['email'], unique=True)
        op.create_index('ix_users_username', 'users', ['username'], unique=True)
        logger.info("usernameとemailのユニークインデックスを作成しました")
        
    except Exception as e:
        logger.warning(f"インデックスまたは制約の更新中にエラーが発生: {e}")
    
    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    try:
        # ステージング環境との整合性を保つために追加したカラムを削除
        if column_exists('users', 'reset_token'):
            op.drop_column('users', 'reset_token')
        
        if column_exists('users', 'reset_token_expires_at'):
            op.drop_column('users', 'reset_token_expires_at')
            
        # インデックスを元に戻す
        op.create_index('ix_sender_recipient', 'sent_messages', ['sender_id', 'recipient_id'], unique=False)
    except Exception as e:
        logger.warning(f"ダウングレード中にエラーが発生: {e}")
    # ### end Alembic commands ###
