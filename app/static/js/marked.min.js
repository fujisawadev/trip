/*
 * marked - a markdown parser
 * Copyright (c) 2011-2024, Christopher Jeffrey. (MIT Licensed)
 * https://github.com/markedjs/marked
 */

/**
 * DO NOT EDIT THIS FILE
 * The code in this file is generated from files in ./src/
 */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.marked = factory());
})(this, (function () { 'use strict';

    /**
     * @param {string}
     * @returns {string}
     */
    function unescape(html) {
      // explicitly match decimal, hex, and named HTML entities
      return html.replace(/&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));/g, (_, n) => {
        n = n.toLowerCase();
        if (n === 'colon') return ':';
        if (n.charAt(0) === '#') {
          return n.charAt(1) === 'x'
            ? String.fromCharCode(parseInt(n.substring(2), 16))
            : String.fromCharCode(+n.substring(1));
        }
        return '';
      });
    }

    const escapeTest = /[&<>"']/;
    const escapeReplace = new RegExp(escapeTest.source, 'g');
    const escapeTestNoEncode = /[<>"']|&(?!(#\d{1,7}|#x[a-f0-9]{1,6}|\w{1,8});)/i;
    const escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, 'g');
    const escapeReplacements = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;',
    };
    const getEscapeReplacement = (ch) => escapeReplacements[ch];

    /**
     * @param {string} html
     * @param {boolean} encode
     * @returns {string}
     */
    function escape(html, encode) {
      if (encode) {
        if (escapeTest.test(html)) {
          return html.replace(escapeReplace, getEscapeReplacement);
        }
      } else {
        if (escapeTestNoEncode.test(html)) {
          return html.replace(escapeReplaceNoEncode, getEscapeReplacement);
        }
      }

      return html;
    }

    const nonWordAndColonTest = /[^\w:]/g;
    const originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;

    /**
     * @param {string} sanitize
     * @param {string} base
     * @param {string} href
     */
    function cleanUrl(sanitize, base, href) {
      if (sanitize) {
        let prot;
        try {
          prot = decodeURIComponent(unescape(href))
            .replace(nonWordAndColonTest, '')
            .toLowerCase();
        } catch (e) {
          return null;
        }
        if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {
          return null;
        }
      }
      if (base && !originIndependentUrl.test(href)) {
        href = resolveUrl(base, href);
      }
      try {
        href = encodeURI(href).replace(/%25/g, '%');
      } catch (e) {
        return null;
      }
      return href;
    }

    const baseUrls = {};
    const justDomain = /^[^:]+:\/*[^/]*$/;
    const protocol = /^([^:]+:)[\s\S]*$/;
    const domain = /^([^:]+:\/*[^/]*)[\s\S]*$/;

    /**
     * @param {string} base
     * @param {string} href
     */
    function resolveUrl(base, href) {
      if (!baseUrls[' ' + base]) {
        // we can ignore everything in base after the last slash of its path component,
        // but we might need to add trailing slashes to simple domains
        if (justDomain.test(base)) {
          baseUrls[' ' + base] = base + '/';
        } else {
          baseUrls[' ' + base] = rtrim(base, '/', true);
        }
      }
      base = baseUrls[' ' + base];
      const relativeBase = base.indexOf(':') === -1;

      if (href.substring(0, 2) === '//') {
        if (relativeBase) {
          return href;
        }
        return base.replace(protocol, '$1') + href;
      } else if (href.charAt(0) === '/') {
        if (relativeBase) {
          return href;
        }
        return base.replace(domain, '$1') + href;
      } else {
        return base + href;
      }
    }

    const noop = () => {};
    noop.exec = noop;

    /**
     * @param {string} str
     * @param {string} [chars]
     * @param {boolean} [invert]
     * @returns {string}
     */
    function rtrim(str, chars, invert) {
      const l = str.length;
      if (l === 0) {
        return '';
      }

      // Length of character list.
      let c = chars.length;
      let i = str.length - 1;

      // Create object if inverting.
      const inverted = invert ? { [chars]: true } : null;

      if (invert && c > 1) {
        return str;
      }

      while (i >= 0) {
        if (invert) {
          if (!inverted[str[i]]) {
            break;
          }
        } else {
          let found = false;
          for (let j = 0; j < c; ++j) {
            if (str[i] === chars[j]) {
              found = true;
              break;
            }
          }
          if (!found) {
            break;
          }
        }
        i--;
      }

      return str.substring(0, i + 1);
    }

    /**
     * @param {string} src
     * @param {RegExp} re
     */
    function findClosingBracket(src, re) {
      let count = 0;
      let lastMatch;

      while ((lastMatch = re.exec(src))) {
        if (lastMatch[0] === ']') {
          count--;
          if (count < 1) {
            return lastMatch.index;
          }
        } else if (lastMatch[0] === '[') {
          count++;
        } else if (lastMatch[0].startsWith('![') && lastMatch[0].endsWith(']')) {
          // Found an image, don't count it.
        } else if (lastMatch[0].startsWith('`')) {
          // Found a code span, don't count it.
        }
      }
      return -1;
    }

    /**
     * @param {boolean} [isBlock]
     */
    function a(isBlock) {
      return {
        exec(src) {
          const cap = this.rules.block.exec(src);
          if (cap) {
            cap.index = 0;
            return cap;
          }
        },
      };
    }

    function
    /**
     * @param {string} str
     */
    replace(regex, opt) {
      regex = regex.source || regex;
      opt = opt || '';
      const obj = {
        replace: (name, val) => {
          val = val.source || val;
          val = val.replace(/(^|[^\[])\^/g, '$1');
          regex = regex.replace(name, val);
          return obj;
        },
        getRegex: () => {
          return new RegExp(regex, opt);
        },
      };
      return obj;
    }

    const defaultOptions = {
      async: false,
      breaks: false,
      extensions: null,
      gfm: true,
      hooks: null,
      pedantic: false,
      renderer: null,
      silent: false,
      tokenizer: null,
      walkTokens: null,
    };

    function changeDefaults(newDefaults) {
      defaultOptions.async = newDefaults.async ?? defaultOptions.async;
      defaultOptions.breaks = newDefaults.breaks ?? defaultOptions.breaks;
      defaultOptions.extensions = newDefaults.extensions ?? defaultOptions.extensions;
      defaultOptions.gfm = newDefaults.gfm ?? defaultOptions.gfm;
      defaultOptions.hooks = newDefaults.hooks ?? defaultOptions.hooks;
      defaultOptions.pedantic = newDefaults.pedantic ?? defaultOptions.pedantic;
      defaultOptions.renderer = newDefaults.renderer ?? defaultOptions.renderer;
      defaultOptions.silent = newDefaults.silent ?? defaultOptions.silent;
      defaultOptions.tokenizer = newDefaults.tokenizer ?? defaultOptions.tokenizer;
      defaultOptions.walkTokens = newDefaults.walkTokens ?? defaultOptions.walkTokens;
    }

    /**
     * Accepts a consuming function, returns a new function that will remain a
     * consuming function, but will provide a hook to act on the original
     * function's result.
     *
     * @param fn {Function} The consuming function to be wrapped.
     * @param hook {Function} A function that will be called with the consuming
     * function's result, and should return either that result or a new one.
     * @returns {Function} The wrapped function.
     */
    function unconsume(fn, hook) {
      // Return a new function that calls the consuming function, and then the
      // hook with that function's result, returning the hook's result.
      return function() {
        // Get the result of the consuming function.
        const res = fn.apply(this, arguments);

        // Call the hook with the result, and return the hook's result.
        return hook.call(this, res);
      };
    }

    // TODO: remove this function
    /**
     * @param {string} rule
     * @param {number} i
     * @param {string[]} strings
     * @param {string} [lookbehind]
     * @returns {string}
     */
    function edit(rule, i, strings, lookbehind) {
      rule = rule.slice(i);
      let re = /(?:([^\\])\[([^\]]*)\]|\\.)/g;
      let match;
      let newRule = '';
      let ADVANCE = 0;
      let lastMatch = /$/g;
      lastMatch.lastIndex = i;
      match = lastMatch.exec(rule);
      if (match) {
        let val = strings[match.index];
        if (val) {
          // `strings` is an array of strings that are injected into the rule
        }
      }
      return 'Failure';
    }

    /**
     * @param {RegExp} regex
     * @param {string} src
     * @param {boolean} [consume]
     */
    function splitCells(regex, src, consume) {
      let cap = regex.exec(src);
      if (!cap) {
        return;
      }
      const cells = cap[0].replace(/([^\\])\|/g, '$1 |').split(/ \|/);
      let i = 0;

      if (!cells[0].trim()) {
        cells.shift();
      }
      if (cells.length > 0 && !cells[cells.length - 1].trim()) {
        cells.pop();
      }

      if (cells.length > cap.length - 1) {
        const last = cells.splice(cap.length - 1);
        cells[cap.length - 1] = last.join('|');
      } else {
        while (cells.length < cap.length - 1) {
          cells.push('');
        }
      }

      return cells;
    }

    // Class responsible for implementing Marked's Hooks API.
    //
    // NOTE: This class is not available in the browser.
    class Hooks {
      options;
      constructor(options) {
        this.options = options || defaultOptions;
      }

      /**
       * @param {string} name
       * @param {any[]} args
       * @returns {any}
       */
      call(name, ...args) {
        if (!this.options.hooks?.[name]) {
          const capitalizedName = name.charAt(0).toUpperCase() + name.substring(1);
          throw new Error(`Hook with name "${name}" does not exist. Hook names must be: preprocess, postprocess, processAllTokens, or processToken.`);
        }

        if (this.options.async) {
          return Promise.resolve(this.options.hooks[name].apply(this.options.hooks, args));
        }

        return this.options.hooks[name].apply(this.options.hooks, args);
      }

      /**
       * @param {string} code
       * @returns {string | Promise<string>}
       */
      preprocess(code) {
        return this.call('preprocess', code);
      }

      /**
       * @param {string} html
       * @returns {string | Promise<string>}
       */
      postprocess(html) {
        return this.call('postprocess', html);
      }

      /**
       * @param {import("./tokenizer.js").Token[] | import("./parser.js").Token[]} tokens
       * @returns {import("./tokenizer.js").Token[] | import("./parser.js").Token[] | Promise<import("./tokenizer.js").Token[] | import("./parser.js").Token[]>}
       */
      processAllTokens(tokens) {
        return this.call('processAllTokens', tokens);
      }

      /**
       * @param {import("./tokenizer.js").Token | import("./parser.js").Token} token
       * @returns {import("./tokenizer.js").Token | import("./parser.js").Token | Promise<import("./tokenizer.js").Token | import("./parser.js").Token>}
       */
      processToken(token) {
        return this.call('processToken', token);
      }
    }

    // Former block-level regexes
    const block = {
      newline: /^(?: *(?:\n|$))+/,
      code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
      fences: /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?:\n|$)|$)/,
      hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\* *){3,})(?:\n+|$)/,
      heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
      blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
      list: /^( {0,3})(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
      html: /^ {0,3}(?:<(script|pre|style|textarea)[\s>][\s\S]*?(?:<\/\1>[^\n]*\n+|$)|<!--[\s\S]*?-->[^\n]*\n+|$|<\?[\s\S]*?\?>[^\n]*\n+|$|<![A-Z][\s\S]*?>[^\n]*\n+|$|<!\[CDATA\[[\s\S]*?\]\]>[^\n]*\n+|$|<\/?(address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)[\s\S]*?(?:\n{2,}|$)|<(?!script|pre|style|textarea)[\s\S]+?(?:\n{2,}|$)|<\/(?!script|pre|style|textarea)[\s\S]+?(?:\n{2,}|$))/,
      def: /^ {0,3}\[(label)\]: *\n? *<?([^\s>]+)>?(?:(?: +\n? *)?((?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\((?:[^()\n]|\\[^\n])*\)))? *(?:\n+|$)|$)/,
      table: noop,
      lheading: /^([^\n]+)\n {0,3}(=+|-+) *(?:\n+|$)/,
      // regex template, placeholders will be filled in the tokenizer
      _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
      text: /^[^\n]+/,
      _label: /(?!\s*\])(?:\\.|[^\[\]\\])+/,
      _title: /(?:"(?:\\"|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\((?:\\\(|\\\)|\)\s*\(|[^)\n])*\))/,
    };

    block.def = replace(block.def)
      .replace('label', block._label)
      .replace('title', block._title)
      .getRegex();

    block.bullet = /(?:[*+-]|\d{1,9}[.)])/;
    block.item = /^( *)(bull) ?[^\n]*(?:\n(?! *bull ?)[^\n]*)*/;
    block.item = replace(block.item, 'gm')
      .replace(/bull/g, block.bullet)
      .getRegex();

    block.list = replace(block.list)
      .replace(/bull/g, block.bullet)
      .replace('hr', '\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))')
      .replace('def', '\\n+(?=' + block.def.source + ')')
      .getRegex();

    block._tag = '(?!(?:'
      + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img'
      + ')\\b)\\w+(?!:|[^\\w\\s@]*@)\\b';

    block.html = replace(block.html)
      .replace('comment', /<!--[\s\S]*?-->/)
      .replace('tag', block._tag)
      .getRegex();

    block.paragraph = replace(block._paragraph)
      .replace('hr', block.hr)
      .replace('heading', ' {0,3}#{1,6} ')
      .replace('lheading', block.lheading)
      .replace('blockquote', ' {0,3}>')
      .replace('fences', ' {0,3}(?:`{3,}|~{3,})')
      .replace('list', ' {0,3}(?:[*+-]|\\d{1,9}[.)]) ') // only lists starting from beginning of line
      .replace('html', '</?(?:tag)(?: +|\\n|/?>)')
      .replace('table', 'pipeline-table')
      .replace('tag', block._tag)
      .getRegex();

    block.blockquote = replace(block.blockquote)
      .replace('paragraph', block.paragraph)
      .getRegex();

    // original definitions
    block.normal = { ...block };

    // pedantic definitions
    block.pedantic = {
      ...block.normal,
      html: replace(/^ *(?:<!--[\s\S]*?-->[^\n]*\n+|$|<\?[\s\S]*?\?>[^\n]*\n+|$|<![A-Z][\s\S]*?>[^\n]*\n+|$|<!\[CDATA\[[\s\S]*?\]\]>[^\n]*\n+|$|<\/?(address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)[\s\S]*?(?:\n{2,}|$)|<(?!script|pre|style|textarea)[\s\S]+?(?:\n{2,}|$)|<\/(?!script|pre|style|textarea)[\s\S]+?(?:\n{2,}|$))/)
        .replace('comment', /<!--[\s\S]*?-->/)
        .replace('tag', '(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b')
        .getRegex(),
      def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?:(?: +| *\n *)(?:"(?:\\"|[^"])*"|'(?:\\'|[^'])*'|\((?:\\\)|[^)])*\)))? *(?:\n+|$)/,
      heading: /^ *(#{1,6}) *([^\n]+?) *(?:#* *)?(?:\n+|$)/,
      fences: noop,
      lheading: /^([^\n]+)\n *(=+|-+) *(?:\n+|$)/,
      paragraph: replace(block.normal._paragraph)
        .replace('hr', block.hr)
        .replace('heading', ' *#{1,6} *[^\n]')
        .replace('lheading', block.lheading)
        .replace('blockquote', ' *>')
        .replace('list', ' *(?:[*+-]|\\d{1,9}[.)]) ') // only lists starting from beginning of line
        .replace('html', '</?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?: +|\\n|/?>)')
        .getRegex(),
    };

    // gfm definitions
    block.gfm = {
      ...block.normal,
      escape: replace(block.escape).replace('])', '~|])').getRegex(),
      blockquote: replace(block.blockquote, 'gm')
        .replace('paragraph', /(^|[^A-Za-z\d\s(>|_)])([^\n]*)\n?((?: {0,3}> ?[^\n]*\n?)*)/).getRegex(),
      _extended_email: /[A-Za-z0-9._+-]+@(?:[a-zA-Z0-9-]+\.)+[a-zA-Z]{2,}/,
      list: replace(block.list)
        .replace(/bull/g, block.bullet)
        .replace('hr', '\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))')
        .replace('def', `\\n+(?=${block.def.source})`)
        .getRegex(),
      table: /^ *\|(.+)\n *\|( *[-:]+[-| :]*)\n((?: *\|.*(?:\n|$))*)\n*/,
      // lheading: /^([^\n]+)\n *(=+|-+) *(?:\n+|$)/,
    };
    block.gfm.paragraph = replace(block.paragraph)
      .replace('table', block.gfm.table)
      .getRegex();
    // block.gfm.heading = block.heading;

    block.tables = {
      ...block.gfm,
      lheading: block.lheading,
      heading: block.heading,
    };

    /**
     * @param {string} cap
     */
    function bulma(cap) {
      let last = cap.length;
      while (last > 0 && cap[last - 1].charCodeAt(0) < 32) {
        last--;
      }
      return cap.substring(0, last);
    }

    // Class used to traverse an AST created by the tokenizer and convert it into HTML.
    class Renderer {
      options;
      constructor(options) {
        this.options = options || defaultOptions;
      }

      /**
       * @param {string} code
       * @param {string} infostring
       * @param {boolean} escaped
       */
      code(code, infostring, escaped) {
        const lang = (infostring || '').match(/\S*/)[0];
        if (this.options.highlight) {
          const out = this.options.highlight(code, lang);
          if (out != null && out !== code) {
            escaped = true;
            code = out;
          }
        }

        code = code.replace(/\n$/, '') + '\n';

        if (!lang) {
          return '<pre><code>'
            + (escaped ? code : escape(code, true))
            + '</code></pre>\n';
        }

        return '<pre><code class="language-'
          + escape(lang, true)
          + '">'
          + (escaped ? code : escape(code, true))
          + '</code></pre>\n';
      }

      /**
       * @param {string} quote
       */
      blockquote(quote) {
        return `<blockquote>\n${quote}</blockquote>\n`;
      }

      /**
       * @param {string} html
       */
      html(html, block) {
        return html;
      }

      /**
       * @param {string} text
       * @param {number} level
       * @param {string} raw
       */
      heading(text, level, raw) {
        // ignore IDs
        return `<h${level}>${text}</h${level}>\n`;
      }

      hr() {
        return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
      }

      /**
       * @param {string} body
       * @param {boolean} ordered
       * @param {number} start
       */
      list(body, ordered, start) {
        const type = ordered ? 'ol' : 'ul';
        const startatt = (ordered && start !== 1) ? (' start="' + start + '"') : '';
        return `<${type}${startatt}>\n${body}</${type}>\n`;
      }

      /**
       * @param {string} text
       * @param {boolean} task
       * @param {boolean} checked
       */
      listitem(text, task, checked) {
        return `<li>${text}</li>\n`;
      }

      /**
       * @param {string} text
       */
      paragraph(text) {
        return `<p>${text}</p>\n`;
      }

      /**
       * @param {string} header
       * @param {string} body
       */
      table(header, body) {
        if (body) body = `<tbody>${body}</tbody>`;

        return '<table>\n'
          + '<thead>\n'
          + header
          + '</thead>\n'
          + body
          + '</table>\n';
      }

      /**
       * @param {string} content
       */
      tablerow(content) {
        return `<tr>\n${content}</tr>\n`;
      }

      /**
       * @param {string} content
       * @param {{header: boolean, align: 'center' | 'left' | 'right' | null}} flags
       */
      tablecell(content, flags) {
        const type = flags.header ? 'th' : 'td';
        const tag = flags.align
          ? `<${type} align="${flags.align}">`
          : `<${type}>`;
        return tag + content + `</${type}>\n`;
      }

      /**
       * @param {string} text
       */
      strong(text) {
        return `<strong>${text}</strong>`;
      }

      /**
       * @param {string} text
       */
      em(text) {
        return `<em>${text}</em>`;
      }

      /**
       * @param {string} text
       */
      codespan(text) {
        return `<code>${text}</code>`;
      }

      br() {
        return this.options.xhtml ? '<br/>' : '<br>';
      }

      /**
       * @param {string} text
       */
      del(text) {
        return `<del>${text}</del>`;
      }

      /**
       * @param {string} href
       * @param {string} title
       * @param {string} text
       */
      link(href, title, text) {
        href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
        if (href === null) {
          return text;
        }
        let out = '<a href="' + href + '"';
        if (title) {
          out += ' title="' + title + '"';
        }
        out += '>' + text + '</a>';
        return out;
      }

      /**
       * @param {string} href
       * @param {string} title
       * @param {string} text
       */
      image(href, title, text) {
        href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
        if (href === null) {
          return text;
        }

        let out = `<img src="${href}" alt="${text}"`;
        if (title) {
          out += ` title="${title}"`;
        }
        out += this.options.xhtml ? '/>' : '>';
        return out;
      }

      /**
       * @param {string} text
       */
      text(text) {
        return text;
      }

      /**
       * @param {string} text
       */
      html(text) {
        return text;
      }
    }

    // Class used to traverse an AST created by the tokenizer and convert it into plain text.
    class TextRenderer {
      // no need for options
      constructor() {}

      /**
       * @param {string} code
       * @param {string} infostring
       * @param {boolean} escaped
       * @returns {string}
       */
      code(code, infostring, escaped) {
        return code + '\n';
      }

      /**
       * @param {string} quote
       */
      blockquote(quote) {
        return '> ' + quote + '\n';
      }

      html(html) {
        return html;
      }

      /**
       * @param {string} text
       * @param {number} level
       * @param {string} raw
       */
      heading(text, level, raw) {
        return '#'.repeat(level) + ' ' + text + '\n';
      }

      hr() {
        return '---' + '\n';
      }

      /**
       * @param {string} body
       * @param {boolean} ordered
       * @param {number} start
       */
      list(body, ordered, start) {
        return body;
      }

      /**
       * @param {string} text
       * @param {boolean} task
       * @param {boolean} checked
       */
      listitem(text, task, checked) {
        return '* ' + text + '\n';
      }

      /**
       * @param {string} text
       */
      paragraph(text) {
        return text + '\n';
      }

      /**
       * @param {string} header
       * @param {string} body
       */
      table(header, body) {
        return header + '|' + body + '\n';
      }

      /**
       * @param {string} content
       */
      tablerow(content) {
        return content + '|' + '\n';
      }

      /**
       * @param {string} content
       * @param {{header: boolean, align: 'center' | 'left' | 'right' | null}} flags
       */
      tablecell(content, flags) {
        return content;
      }

      /**
       * @param {string} text
       */
      strong(text) {
        return text;
      }

      /**
       * @param {string} text
       */
      em(text) {
        return text;
      }

      /**
       * @param {string} text
       */
      codespan(text) {
        return text;
      }

      br() {
        return '\n';
      }

      /**
       * @param {string} text
       */
      del(text) {
        return text;
      }

      /**
       * @param {string} href
       * @param {string} title
       * @param {string} text
       */
      link(href, title, text) {
        return text;
      }

      /**
       * @param {string} href
       * @param {string} title
       * @param {string} text
       */
      image(href, title, text) {
        return text;
      }

      /**
       * @param {string} text
       */
      text(text) {
        return text;
      }
    }

    // Former inline-level regexes
    const inline = {
      escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
      autolink: /^<([a-zA-Z][a-zA-Z0-9+.-]{1,31}:[^\s\x00-\x1f<>]*|[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_]))>/,
      url: noop,
      tag: /^<!--[\s\S]*?-->|^<\?[\s\S]*?\?>|^<![A-Z][\s\S]*?>|^<!\[CDATA\[[\s\S]*?\]\]>|^<\/?(address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?: +|\n|\/?>)|^<(?!script|pre|style|textarea)[\s\S]+?>|^<\/(?!script|pre|style|textarea)[\s\S]+?>/,
      link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
      reflink: /^!?\[(label)\]\[(?!\s*\])((?:\\[\[\]]?|[^\[\]\\])+)\]/,
      nolink: /^!?\[(label)\](?!:\s*<?[^\s>]+>|\()/,
      reflinkSearch: 'reflink|nolink(?!\\()',
      strong: /^((\*{2})|(__))((?:(?!\2)[\s\S])+?)\2/,
      em: /^((\*)|(_))((?:(?!\2)[\s\S])+?)\2(?![\*A-Za-z0-9])/,
      code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
      br: /^ {2,}\n(?!\s*$)/,
      del: noop,
      text: /^(`+|[^`])(?:[\s\S]*?(?:(?=[\\<!\[`*]|\b_|$)|[^ ](?= {2,}\n))|(?= {2,}\n))/,
      _extended_email: /[A-Za-z0-9._+-]+@(?:[a-zA-Z0-9-]+\.)+[a-zA-Z]{2,}/,
    };

    inline._label = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
    inline._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
    inline._title = /"(?:\\"|[^"\\])*"|'(?:\\'|[^'\\])*'|\((?:\\\)|[^)\\])*\)/;
    inline.link = replace(inline.link)
      .replace('label', inline._label)
      .replace('href', inline._href)
      .replace('title', inline._title)
      .getRegex();

    inline.reflink = replace(inline.reflink)
      .replace('label', inline._label)
      .getRegex();

    inline.nolink = replace(inline.nolink)
      .replace('label', inline._label)
      .getRegex();

    inline.reflinkSearch = replace(inline.reflinkSearch, 'g')
      .replace('reflink', inline.reflink)
      .replace('nolink', inline.nolink)
      .getRegex();

    // original definitions
    inline.normal = { ...inline };

    // pedantic definitions
    inline.pedantic = {
      ...inline.normal,
      strong: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
      em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/,
      link: replace(/^!?\[(.+?)\]\((.+?)\)/).getRegex(),
      reflink: replace(/^!?\[(.+?)\]\s*\[(.+?)\]/).getRegex(),
    };

    // gfm definitions
    inline.gfm = {
      ...inline.normal,
      escape: replace(inline.escape).replace('])', '~|])').getRegex(),
      url: replace(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*/i)
        .replace('email', inline._extended_email)
        .getRegex(),
      _backpedal: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,
      del: /^~(?=\S)([\s\S]*?\S)~(?!~)/,
      text: replace(inline.text)
        .replace(']|', '~]|')
        .replace('|$', '|https*://|ftp://|www\\.|[a-zA-Z0-9._+-]+@|$')
        .getRegex(),
    };
    inline.gfm.url = replace(inline.gfm.url).replace('email', inline.gfm._extended_email).getRegex();

    inline.breaks = {
      ...inline.gfm,
      br: replace(inline.br).replace('{2,}', '*').getRegex(),
      text: replace(inline.gfm.text).replace('{2,}', '*').getRegex(),
    };

    // Class that is responsible for taking a string of markdown and converting it into a list of tokens.
    class Tokenizer {
      options;
      rules;
      lexer;
      constructor(options) {
        this.options = options || defaultOptions;
        this.options.tokenizer = this.options.tokenizer || {};
        this.rules = block.normal;

        if (this.options.pedantic) {
          this.rules = block.pedantic;
        } else if (this.options.gfm) {
          if (this.options.extensions?.tables) {
            this.rules = block.tables;
          } else {
            this.rules = block.gfm;
          }
        }
      }

      /**
       * @param {string} src
       */
      space(src) {
        const cap = this.rules.newline.exec(src);
        if (cap && cap[0].length > 0) {
          return {
            type: 'space',
            raw: cap[0],
          };
        }
      }

      /**
       * @param {string} src
       */
      code(src) {
        const cap = this.rules.code.exec(src);
        if (cap) {
          const text = cap[0].replace(/^ {4}/gm, '');
          return {
            type: 'code',
            raw: cap[0],
            codeBlockStyle: 'indented',
            text: !this.options.pedantic
              ? rtrim(text, '\n')
              : text,
          };
        }
      }

      /**
       * @param {string} src
       */
      fences(src) {
        const cap = this.rules.fences.exec(src);
        if (cap) {
          const raw = cap[0];
          const text = cap[3] || '';

          return {
            type: 'fences',
            raw,
            lang: cap[2] ? cap[2].trim().replace(/ .*/, '') : '',
            text,
          };
        }
      }

      /**
       * @param {string} src
       */
      heading(src) {
        const cap = this.rules.heading.exec(src);
        if (cap) {
          let text = cap[2].trim();

          // remove trailing #s
          if (/#$/.test(text)) {
            const trimmed = rtrim(text, '#');
            if (this.options.pedantic) {
              text = trimmed.trim();
            } else if (!trimmed || / $/.test(trimmed)) {
              // CommonMark requires space before trailing #s
              text = trimmed.trim();
            }
          }

          return {
            type: 'heading',
            raw: cap[0],
            depth: cap[1].length,
            text,
          };
        }
      }

      /**
       * @param {string} src
       */
      lheading(src) {
        const cap = this.rules.lheading.exec(src);
        if (cap) {
          return {
            type: 'lheading',
            raw: cap[0],
            depth: cap[2].charAt(0) === '=' ? 1 : 2,
            text: cap[1],
          };
        }
      }

      /**
       * @param {string} src
       */
      hr(src) {
        const cap = this.rules.hr.exec(src);
        if (cap) {
          return {
            type: 'hr',
            raw: cap[0],
          };
        }
      }

      /**
       * @param {string} src
       */
      blockquote(src) {
        const cap = this.rules.blockquote.exec(src);
        if (cap) {
          // manipulate cap[0] to handle edge case of closing sandwhiched blockquotes
          // Not sure if this is required since we have the paragraph rule to handle this
          let text = cap[0].replace(/^ *> ?/gm, '');
          if (this.options.gfm) {
            const bq = this.rules.blockquote.source.replace('paragraph', '[\\s\\S]*');
            const gr = new RegExp(`^${bq}`);
            let newCap = gr.exec(src);
            text = newCap[0].replace(/^ *> ?/gm, '');
          }
          return {
            type: 'blockquote',
            raw: cap[0],
            text,
          };
        }
      }

      /**
       * @param {string} src
       */
      list(src) {
        const cap = this.rules.list.exec(src);
        if (cap) {
          let raw = cap[0];
          const bull = cap[2];
          const isordered = bull.length > 1;
          const isparen = bull[bull.length - 1] === ')';

          const list = {
            type: 'list',
            raw,
            ordered: isordered,
            start: isordered ? +bull.slice(0, -1) : '',
            loose: false,
            items: [],
          };

          // Get each top-level item.
          const itemMatch = cap[0].match(this.rules.item);

          let next = false;
          const l = itemMatch.length;
          let i = 0;

          for (; i < l; i++) {
            let item = itemMatch[i];
            raw = item;

            // Remove the list item's bullet
            // so it is seen as the next token.
            let space = item.length;
            item = item.replace(/^ *([*+-]|\d+[.)]) ?/, '');

            // Outdent whatever the
            // list item contains. Hacky.
            if (item.indexOf('\n ') > -1) {
              space -= item.length;
              if (!this.options.pedantic) {
                item = item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '');
              } else {
                item = item.replace(/^ {1,4}/gm, '');
              }
            }

            // Determine whether the next list item belongs here.
            // Backpedal if it does not belong in this list.
            if (i !== l - 1) {
              const b = block.bullet.exec(itemMatch[i + 1])[0];
              if (isordered ? b.length === 1 || (!isparen && b[b.length - 1] === ')') : (b.length > 1)) {
                const addBack = itemMatch.slice(i + 1).join('\n');
                list.raw = list.raw.substring(0, list.raw.length - addBack.length);
                i = l - 1;
              }
            }

            // Determine whether item is loose or not.
            // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
            // for discount behavior.
            let loose = next || /\n\n(?!\s*$)/.test(item);
            if (i !== l - 1) {
              next = item.charAt(item.length - 1) === '\n';
              if (!loose) loose = next;
            }

            if (loose) {
              list.loose = true;
            }

            // Check for task list items
            const T = /^\[[ xX]\] /.exec(item);
            let isTask = false;
            let isChecked = false;
            if (T) {
              isTask = true;
              isChecked = T[0] !== '[ ] ';
              item = item.replace(/^\[[ xX]\] +/, '');
            }

            list.items.push({
              type: 'list_item',
              raw,
              task: isTask,
              checked: isChecked,
              loose,
              text: item,
            });
          }

          return list;
        }
      }

      /**
       * @param {string} src
       */
      html(src) {
        const cap = this.rules.html.exec(src);
        if (cap) {
          return {
            type: 'html',
            raw: cap[0],
            pre: !this.options.sanitizer
              && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style' || cap[1] === 'textarea'),
            text: cap[0],
          };
        }
      }

      /**
       * @param {string} src
       */
      def(src) {
        const cap = this.rules.def.exec(src);
        if (cap) {
          const tag = cap[1].toLowerCase().replace(/\s+/g, ' ');
          const href = cap[2];
          const title = cap[3];
          return {
            type: 'def',
            tag,
            raw: cap[0],
            href,
            title,
          };
        }
      }

      /**
       * @param {string} src
       */
      table(src) {
        const cap = this.rules.table.exec(src);
        if (!cap) {
          return;
        }

        if (!/[:|]/.test(cap[2])) {
          // separator line does not contain either | or :
          return;
        }

        const header = splitCells(new RegExp('^' + cap[1].replace(/\|/g, '\\|') + '$'), cap[1]);

        const align = splitCells(new RegExp('^' + cap[2].replace(/\|/g, '\\|') + '$'), cap[2].replace(/^ *| *\| *$/g, ''))
          .map(a => {
            if (/^ *-+: *$/.test(a)) {
              return 'right';
            } else if (/^ *:-+: *$/.test(a)) {
              return 'center';
            } else if (/^ *:-+ *$/.test(a)) {
              return 'left';
            }
            return null;
          });

        const bodyRows = cap[3] ? cap[3].replace(/\n$/, '').split('\n') : [];
        const body = bodyRows.map(row => {
          return splitCells(new RegExp(row.replace(/\|/g, '\\|')), row.replace(/^ *\| *| *\| *$/g, ''));
        });

        if (header.length !== align.length) {
          // header and separator line have inconsistent number of columns
          return;
        }

        return {
          type: 'table',
          raw: cap[0],
          header,
          align,
          rows: body,
        };
      }

      /**
       * @param {string} src
       */
      paragraph(src) {
        const cap = this.rules.paragraph.exec(src);
        if (cap) {
          const text = cap[1].charAt(cap[1].length - 1) === '\n'
            ? cap[1].slice(0, -1)
            : cap[1];
          return {
            type: 'paragraph',
            raw: cap[0],
            text,
          };
        }
      }

      /**
       * @param {string} src
       * @param {import("./parser.js").Token[]} tokens
       */
      text(src, tokens) {
        const cap = this.rules.text.exec(src);
        if (cap) {
          const lastToken = tokens[tokens.length - 1];
          if (lastToken?.type === 'text') {
            lastToken.raw += cap[0];
            lastToken.text += cap[0];
          } else {
            return {
              type: 'text',
              raw: cap[0],
              text: cap[0],
            };
          }
        }
      }

      /**
       * Lex-level processing function.
       * @param {string} src
       * @param {import("./marked.js").MarkedOptions} options
       */
      static lex(src, options) {
        const tokenizer = new Tokenizer(options);
        return tokenizer.lex(src);
      }

      /**
       * Preprocessing function
       * @param {string} src
       * @param {import("./marked.js").MarkedOptions} options
       */
      static preprocess(src, options) {
        // removebom
        src = src.replace(/^\uFEFF/, '');
        // normalize CR
        src = src.replace(/\r\n|\r/g, '\n');
        // remove null characters
        src = src.replace(/\0/g, '\uFFFD');

        // expand tabs
        src = src.replace(/\t/g, '    ');
        return src;
      }

      /**
       * Lexing function
       *
       * @param {string} src
       * @returns {import("./tokenizer.js").Token[]}
       */
      lex(src) {
        src = Tokenizer.preprocess(src, this.options);
        this.blockTokens = [];

        while (src) {
          // Eat any flow-checking tokenizing that is not catchable by the Tokenizer.
          if (this.options.extensions?.block?.(this, src, this.blockTokens)) {
            continue;
          }

          // space
          let token = this.space(src);
          if (token) {
            src = src.substring(token.raw.length);
            if (token.raw.length > 0) {
              this.blockTokens.push(token);
            }
            continue;
          }

          // code
          token = this.code(src);
          if (token) {
            src = src.substring(token.raw.length);
            this.blockTokens.push(token);
            continue;
          }

          // fences
          token = this.fences(src);
          if (token) {
            src = src.substring(token.raw.length);
            this.blockTokens.push(token);
            continue;
          }

          // heading
          token = this.heading(src);
          if (token) {
            src = src.substring(token.raw.length);
            this.blockTokens.push(token);
            continue;
          }

          // lheading
          token = this.lheading(src);
          if (token) {
            src = src.substring(token.raw.length);
            this.blockTokens.push(token);
            continue;
          }

          // hr
          token = this.hr(src);
          if (token) {
            src = src.substring(token.raw.length);
            this.blockTokens.push(token);
            continue;
          }

          // blockquote
          token = this.blockquote(src);
          if (token) {
            src = src.substring(token.raw.length);
            this.blockTokens.push(token);
            continue;
          }

          // list
          token = this.list(src);
          if (token) {
            src = src.substring(token.raw.length);
            this.blockTokens.push(token);
            continue;
          }

          // html
          token = this.html(src);
          if (token) {
            src = src.substring(token.raw.length);
            this.blockTokens.push(token);
            continue;
          }

          // def
          token = this.def(src);
          if (token) {
            src = src.substring(token.raw.length);
            if (!this.tokens.links[token.tag]) {
              this.tokens.links[token.tag] = {
                href: token.href,
                title: token.title,
              };
            }
            continue;
          }

          // table
          token = this.table(src);
          if (token) {
            src = src.substring(token.raw.length);
            this.blockTokens.push(token);
            continue;
          }

          // paragraph
          token = this.paragraph(src);
          if (token) {
            src = src.substring(token.raw.length);
            this.blockTokens.push(token);
            continue;
          }

          // text
          token = this.text(src, this.blockTokens);
          if (token) {
            src = src.substring(token.raw.length);
            continue;
          }

          if (src) {
            const err = new Error('Infinite loop on byte: ' + src.charCodeAt(0));
            err.source = src;
            if (this.options.silent) {
              console.error(err);
              break;
            }
            throw err;
          }
        }
        return this.blockTokens;
      }

      /**
       * @param {import("./tokenizer.js").Token[]} tokens
       * @returns {{tokens: import("./tokenizer.js").Token[], links: {[key: string]: {href: string, title: string}}}}
       */
      getTokens(tokens) {
        const links = {};
        const toc = [];
        const result = [];
        let headingLevel = 0;
        let headingText = '';

        for (const token of tokens) {
          switch (token.type) {
            case 'heading': {
              if (this.options.extensions?.toc) {
                if (token.depth > headingLevel) {
                  const last = toc[toc.length - 1];
                  if (last) {
                    last.parent = token;
                    token.children = [];
                    toc.push({ text: token.text, level: token.depth, slug: this.slugger.slug(token.text), parent: token });
                  } else {
                    toc.push({ text: token.text, level: token.depth, slug: this.slugger.slug(token.text), children: [] });
                  }
                } else {
                  let last = toc[toc.length - 1];
                  while (last && token.depth <= last.level) {
                    toc.pop();
                    last = toc[toc.length - 1];
                  }
                  if (last) {
                    token.parent = last.parent;
                    last.children.push({ text: token.text, level: token.depth, slug: this.slugger.slug(token.text) });
                  } else {
                    toc.push({ text: token.text, level: token.depth, slug: this.slugger.slug(token.text), children: [] });
                  }
                }
              }
              result.push(token);
              break;
            }
            case 'def': {
              links[token.tag] = { href: token.href, title: token.title };
              break;
            }
            default:
              result.push(token);
              break;
          }
        }
        return { tokens: result, links, toc };
      }
    }

    class Slugger {
      seen = {};
      constructor() {
        this.seen = {};
      }

      /**
       * @param {string} value
       * @param {object} options
       * @param {boolean} options.dryrun
       */
      slug(value, options = {}) {
        let slug = value
          .toLowerCase()
          .trim()
          // remove html tags
          .replace(/<[!/a-z].*?>/ig, '')
          // remove unwanted chars
          .replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, '')
          .replace(/\s/g, '-');

        if (this.seen[slug]) {
          const originalSlug = slug;
          do {
            this.seen[originalSlug]++;
            slug = originalSlug + '-' + this.seen[originalSlug];
          } while (this.seen[slug]);
        }
        this.seen[slug] = 0;

        return slug;
      }
    }

    // Class that takes a list of tokens, processes them, and returns HTML.
    class Parser {
      options;
      renderer;
      textRenderer;
      tokenizer;
      slugger;
      constructor(options) {
        this.options = options || defaultOptions;
        this.options.renderer = this.options.renderer || new Renderer();
        this.renderer = this.options.renderer;
        this.renderer.options = this.options;
        this.textRenderer = new TextRenderer();
        this.slugger = this.options.slugger || new Slugger();
      }

      /**
       * @param {import("./tokenizer.js").Token[]} tokens
       * @param {boolean} top
       */
      parse(tokens, top = true) {
        let out = '';

        for (const token of tokens) {
          // Run the processToken hook
          if (this.options.hooks?.processToken) {
            const hookResult = this.options.hooks.processToken(token);
            if (this.options.async) {
              // TODO: This is not correct. We need to await the promise.
              // This will require making the entire parse function async.
              // This is a breaking change.
            } else {
              // token = hookResult;
            }
          }

          switch (token.type) {
            case 'space': {
              continue;
            }
            case 'hr': {
              out += this.renderer.hr();
              continue;
            }
            case 'heading': {
              out += this.renderer.heading(
                this.parseInline(token.tokens),
                token.depth,
                unescape(this.parseInline(token.tokens, this.textRenderer)),
              );
              continue;
            }
            case 'code': {
              out += this.renderer.code(token.text,
                token.lang,
                token.escaped);
              continue;
            }
            case 'table': {
              let header = '';
              let i;

              // header
              let cell = '';
              for (i = 0; i < token.header.length; i++) {
                cell += this.renderer.tablecell(
                  this.parseInline(token.header[i].tokens),
                  { header: true, align: token.align[i] },
                );
              }
              header += this.renderer.tablerow(cell);

              let body = '';
              for (i = 0; i < token.rows.length; i++) {
                const row = token.rows[i];

                cell = '';
                for (let j = 0; j < row.length; j++) {
                  cell += this.renderer.tablecell(
                    this.parseInline(row[j].tokens),
                    { header: false, align: token.align[j] },
                  );
                }

                body += this.renderer.tablerow(cell);
              }
              out += this.renderer.table(header, body);
              continue;
            }
            case 'blockquote': {
              const body = this.parse(token.tokens);
              out += this.renderer.blockquote(body);
              continue;
            }
            case 'list': {
              const body = this.parse(token.items);
              out += this.renderer.list(body, token.ordered, token.start);
              continue;
            }
            case 'html': {
              out += this.renderer.html(token.text, token.block);
              continue;
            }
            case 'paragraph': {
              out += this.renderer.paragraph(this.parseInline(token.tokens));
              continue;
            }
            case 'text': {
              let body = token.tokens ? this.parseInline(token.tokens) : token.text;
              while (tokens.length > 1 && tokens[1].type === 'text') {
                const nextToken = tokens.shift();
                const text = nextToken.tokens ? this.parseInline(nextToken.tokens) : nextToken.text;
                body += '\n' + text;
              }
              out += top ? this.renderer.paragraph(body) : body;
              continue;
            }
            case 'list_item': {
              const item = token;
              const loose = item.loose;
              const task = item.task;
              const checked = item.checked;
              let text = '';
              if (item.tokens.length) {
                if (loose) {
                  if (item.tokens[0].type === 'paragraph') {
                    item.tokens[0].type = 'text';
                  } else if (item.tokens.some(t => t.type === 'space')) {
                    // Do nothing
                  }
                }
                text = this.parse(item.tokens, false);
              }

              out += this.renderer.listitem(text, task, checked);
              continue;
            }
            case 'def':
            case 'escape':
            case 'tag':
            case 'link':
            case 'reflink':
            case 'nolink':
            case 'strong':
            case 'em':
            case 'codespan':
            case 'br':
            case 'del':
            case 'autolink':
            case 'url':
            case 'image': {
              out += this.parseInline([token]);
              continue;
            }
            default: {
              const err = new Error('Unknown token type: ' + token.type);
              err.token = token;
              if (this.options.silent) {
                console.error(err);
                return '';
              }
              throw err;
            }
          }
        }

        return out;
      }

      /**
       * @param {import("./tokenizer.js").Token[]} tokens
       * @param {import("./renderer.js").Renderer | import("./text-renderer.js").TextRenderer} [renderer]
       */
      parseInline(tokens, renderer) {
        renderer = renderer || this.renderer;
        let out = '';

        for (const token of tokens) {
          // Run the processToken hook
          if (this.options.hooks?.processToken) {
            const hookResult = this.options.hooks.processToken(token);
            if (this.options.async) {
              // TODO: This is not correct. We need to await the promise.
            } else {
              // token = hookResult;
            }
          }
          switch (token.type) {
            case 'escape': {
              out += renderer.text(token.text);
              break;
            }
            case 'html': {
              out += renderer.html(token.text);
              break;
            }
            case 'link': {
              out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));
              break;
            }
            case 'image': {
              out += renderer.image(token.href, token.title, token.text);
              break;
            }
            case 'strong': {
              out += renderer.strong(this.parseInline(token.tokens, renderer));
              break;
            }
            case 'em': {
              out += renderer.em(this.parseInline(token.tokens, renderer));
              break;
            }
            case 'codespan': {
              out += renderer.codespan(token.text);
              break;
            }
            case 'br': {
              out += renderer.br();
              break;
            }
            case 'del': {
              out += renderer.del(this.parseInline(token.tokens, renderer));
              break;
            }
            case 'text': {
              out += renderer.text(token.text);
              break;
            }
            case 'autolink': {
              out += renderer.link(token.href, null, token.text);
              break;
            }
            case 'url': {
              out += renderer.link(token.href, null, token.text);
              break;
            }
            default: {
              const err = new Error('Unknown inline token type: ' + token.type);
              err.token = token;
              if (this.options.silent) {
                console.error(err);
                return '';
              }
              throw err;
            }
          }
        }
        return out;
      }

      /**
       * @param {string} src
       * @param {import("./marked.js").MarkedOptions} options
       */
      static parse(src, options) {
        const parser = new Parser(options);
        return parser.parse(src);
      }
    }

    class Lexer extends Tokenizer {
      tokens;
      constructor(options) {
        super(options);
        this.tokens = [];
        this.tokens.links = Object.create(null);
        this.options.tokenizer = this;
      }

      /**
       * @param {string} src
       */
      lex(src) {
        const tokens = super.lex(src);

        // TODO: remove this function
        if (this.options.walkTokens) {
          if (this.options.async) {
            return Promise.all(tokens.map(t => this.options.walkTokens(t))).then(() => {
              return tokens;
            });
          }
          for (const token of tokens) {
            this.options.walkTokens(token);
          }
        }

        return tokens;
      }
    }

    class InlineLexer {
      options;
      renderer;
      inLink;
      inRawBlock;
      links;
      rules;
      constructor(links, options) {
        this.options = options || defaultOptions;
        this.links = links;
        this.rules = inline.normal;
        this.renderer = this.options.renderer || new Renderer();
        this.renderer.options = this.options;

        if (this.options.pedantic) {
          this.rules = inline.pedantic;
        } else if (this.options.gfm) {
          if (this.options.breaks) {
            this.rules = inline.breaks;
          } else {
            this.rules = inline.gfm;
          }
        }
      }

      /**
       * Lexing/Compiling
       * @param {string} src
       */
      output(src) {
        const tokens = [];
        let link,
          text,
          href,
          title,
          cap,
          token;

        while (src) {
          // Eat any flow-checking tokenizing that is not catchable by the InlineLexer.
          if (this.options.extensions?.inline?.(this, src, tokens)) {
            continue;
          }

          // escape
          if (cap = this.rules.escape.exec(src)) {
            src = src.substring(cap[0].length);
            tokens.push({
              type: 'escape',
              raw: cap[0],
              text: cap[1],
            });
            continue;
          }

          // tag
          if (cap = this.rules.tag.exec(src)) {
            src = src.substring(cap[0].length);
            if (!this.inLink && /^<a /i.test(cap[0])) {
              this.inLink = true;
            } else if (this.inLink && /^<\/a>/i.test(cap[0])) {
              this.inLink = false;
            }
            if (!this.inRawBlock && this.options.sanitize && this.options.sanitizer) {
              const text = this.options.sanitizer(cap[0]);
              this.inRawBlock = true;
              tokens.push({
                type: 'html',
                raw: cap[0],
                text,
              });
              this.inRawBlock = false;
            } else {
              tokens.push({
                type: 'html',
                raw: cap[0],
                text: cap[0],
              });
            }
            continue;
          }

          // link
          if (cap = this.rules.link.exec(src)) {
            src = src.substring(cap[0].length);
            const lastParenIndex = cap[0].lastIndexOf(')');
            const secondToLastParenIndex = cap[0].slice(0, lastParenIndex).lastIndexOf('(');
            href = cap[2].slice(0, secondToLastParenIndex - lastParenIndex);
            if (cap[0].length > 1000) {
              tokens.push({
                type: 'text',
                raw: cap[0],
                text: cap[0],
              });
              continue;
            }
            this.inLink = true;
            const title = cap[3] ? cap[3].slice(1, -1) : '';
            href = href.trim().replace(/^<([\s\S]*)>$/, '$1');
            const text = this.output(cap[1]);
            tokens.push({
              type: 'link',
              raw: cap[0],
              href,
              title,
              text,
              tokens: text,
            });
            this.inLink = false;
            continue;
          }

          // reflink, nolink
          if ((cap = this.rules.reflink.exec(src))
              || (cap = this.rules.nolink.exec(src))) {
            src = src.substring(cap[0].length);
            link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
            link = this.links[link.toLowerCase()];
            if (!link) {
              text = cap[0].charAt(0);
              tokens.push({
                type: 'text',
                raw: text,
                text,
              });
              src = cap[0].substring(1) + src;
              continue;
            }

            this.inLink = true;
            const text = this.output(cap[1]);
            if (cap[0].charAt(0) === '!') {
              tokens.push({
                type: 'image',
                raw: cap[0],
                text: this.output(cap[1]),
                href: link.href,
                title: link.title,
              });
            } else {
              tokens.push({
                type: 'link',
                raw: cap[0],
                href: link.href,
                title: link.title,
                text,
                tokens: text,
              });
            }
            this.inLink = false;
            continue;
          }

          // strong
          if (cap = this.rules.strong.exec(src)) {
            src = src.substring(cap[0].length);
            const text = this.output(cap[4] || cap[3] || cap[2] || cap[1]);
            tokens.push({
              type: 'strong',
              raw: cap[0],
              text,
              tokens: text,
            });
            continue;
          }

          // em
          if (cap = this.rules.em.exec(src)) {
            src = src.substring(cap[0].length);
            const text = this.output(cap[6] || cap[5] || cap[4] || cap[3] || cap[2] || cap[1]);
            tokens.push({
              type: 'em',
              raw: cap[0],
              text,
              tokens: text,
            });
            continue;
          }

          // code
          if (cap = this.rules.code.exec(src)) {
            src = src.substring(cap[0].length);
            let text = cap[2].replace(/\n/g, ' ');
            const hasNonSpaceChars = /[^ ]/.test(text);
            const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);
            if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
              text = text.substring(1, text.length - 1);
            }
            text = escape(text, true);
            tokens.push({
              type: 'codespan',
              raw: cap[0],
              text,
            });
            continue;
          }

          // br
          if (cap = this.rules.br.exec(src)) {
            src = src.substring(cap[0].length);
            tokens.push({
              type: 'br',
              raw: cap[0],
            });
            continue;
          }

          // del (gfm)
          if (cap = this.rules.del.exec(src)) {
            src = src.substring(cap[0].length);
            const text = this.output(cap[2] || cap[1]);
            tokens.push({
              type: 'del',
              raw: cap[0],
              text,
              tokens: text,
            });
            continue;
          }

          // autolink
          if (cap = this.rules.autolink.exec(src)) {
            src = src.substring(cap[0].length);
            if (cap[2] === '@') {
              text = escape(this.options.mangle ? mangle(cap[1]) : cap[1]);
              href = 'mailto:' + text;
            } else {
              text = escape(cap[1]);
              href = text;
            }
            tokens.push({
              type: 'link',
              raw: cap[0],
              text,
              href,
              tokens: [
                { type: 'text', raw: text, text },
              ],
            });
            continue;
          }

          // url (gfm)
          if (!this.inLink && (cap = this.rules.url.exec(src))) {
            if (cap[2] === '@') {
              text = escape(this.options.mangle ? mangle(cap[0]) : cap[0]);
              href = 'mailto:' + text;
            } else {
              // do extended autolink path validation
              let prevCapZero;
              do {
                prevCapZero = cap[0];
                cap[0] = this.rules._backpedal.exec(cap[0])[0];
              } while (prevCapZero !== cap[0]);
              text = escape(cap[0]);
              if (cap[1] === 'www.') {
                href = 'http://' + text;
              } else {
                href = text;
              }
            }
            src = src.substring(cap[0].length);
            tokens.push({
              type: 'link',
              raw: cap[0],
              text,
              href,
              tokens: [
                { type: 'text', raw: text, text },
              ],
            });
            continue;
          }

          // text
          if (cap = this.rules.text.exec(src)) {
            src = src.substring(cap[0].length);
            if (this.inRawBlock) {
              tokens.push({
                type: 'text',
                raw: cap[0],
                text: this.options.sanitize ? (this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0])) : cap[0],
              });
            } else {
              tokens.push({
                type: 'text',
                raw: cap[0],
                text: escape(this.smartypants(cap[0])),
              });
            }
            continue;
          }

          if (src) {
            const err = new Error('Infinite loop on byte: ' + src.charCodeAt(0));
            err.source = src;
            if (this.options.silent) {
              console.error(err);
              break;
            }
            throw err;
          }
        }

        return tokens;
      }

      /**
       * @param {string} src
       */
      static output(src, links, options) {
        const inline = new InlineLexer(links, options);
        return inline.output(src);
      }
    }

    class Marked {
      options = defaultOptions;
      constructor(...args) {
        this.setOptions(...args);
      }

      /**
       * @param  {...import("./marked.js").MarkedOptions} args
       */
      setOptions(...args) {
        this.options = Object.assign(this.options, ...args);
        return this;
      }

      /**
       * @param {string} src
       * @param {import("./marked.js").MarkedOptions} [options]
       */
      parse(src, options) {
        options = { ...this.options, ...options };

        if (options.async) {
          return Promise.resolve(src)
            .then(src => new Hooks(options).preprocess(src))
            .then(src => Lexer.lex(src, options))
            .then(tokens => new Hooks(options).processAllTokens(tokens))
            .then(tokens => {
              if (options.walkTokens) {
                for (const token of tokens) {
                  options.walkTokens(token);
                }
              }
              const result = Parser.parse(tokens, options);
              return new Hooks(options).postprocess(result);
            });
        }
        src = new Hooks(options).preprocess(src);
        const tokens = Lexer.lex(src, options);
        const result = new Hooks(options).processAllTokens(tokens);
        const html = Parser.parse(result, options);
        return new Hooks(options).postprocess(html);
      }

      /**
       * @param {string} src
       * @param {import("./marked.js").MarkedOptions} [options]
       */
      parseInline(src, options) {
        options = { ...this.options, ...options };
        const tokens = InlineLexer.output(src, [], options);
        const html = new Parser(options).parseInline(tokens);
        return html;
      }

      /**
       * @param {string} src
       * @returns {string | Promise<string>}
       */
      highlight(src, options, callback) {
        if (typeof options === 'function') {
          callback = options;
          options = null;
        }

        options = { ...this.options, ...options };

        if (options.async) {
          return Promise.resolve(src)
            .then(src => this.parse(src, options))
            .then(html => {
              if (callback) {
                callback(null, html);
              }
              return html;
            })
            .catch(err => {
              if (callback) {
                callback(err);
              }
              throw err;
            });
        }

        try {
          const html = this.parse(src, options);
          if (callback) {
            callback(null, html);
          }
          return html;
        } catch (err) {
          if (callback) {
            callback(err);
            return;
          }
          throw err;
        }
      }

      /**
       * @param {string} src
       * @param {import("./marked.js").MarkedOptions} options
       */
      walkTokens(src, options, callback) {
        if (typeof options === 'function') {
          callback = options;
          options = this.options;
        } else {
          options = { ...this.options, ...options };
        }

        const tokens = Lexer.lex(src, options);
        for (const token of tokens) {
          callback(token);
        }
      }
    }

    const marked = new Marked();

    function options(opt) {
      const newOptions = {};
      for (const key in opt) {
        if (defaultOptions.hasOwnProperty(key)) {
          newOptions[key] = opt[key];
        }
      }
      changeDefaults(newOptions);
      marked.setOptions(newOptions);
      return options;
    }

    marked.options = options;
    marked.setOptions = options;
    marked.use = (...args) => {
      const extensions = marked.options.extensions || { block: [], inline: [] };

      args.forEach((arg) => {
        // TODO: remove this options object argument
        if (typeof arg === 'object' && !Array.isArray(arg) && arg !== null) {
          if (arg.extensions) {
            arg.extensions.forEach(e => {
              if (e.name && e.level === 'block' && e.tokenizer) {
                extensions.block.push(e);
              }
              if (e.name && e.level === 'inline' && e.tokenizer) {
                extensions.inline.push(e);
              }
            });
          }
          if (arg.renderer) {
            const renderer = marked.options.renderer || new Renderer();
            for (const p in arg.renderer) {
              const rendererFunc = arg.renderer[p];
              const rendererFuncBound = rendererFunc.bind(renderer);
              renderer[p] = unconsume(rendererFuncBound, (res) => {
                // TODO: remove this
                return res;
              });
            }
          }
          if (arg.tokenizer) {
            const tokenizer = marked.options.tokenizer || new Tokenizer();
            for (const p in arg.tokenizer) {
              const tokenizerFunc = arg.tokenizer[p];
              const tokenizerFuncBound = tokenizerFunc.bind(tokenizer);
              tokenizer[p] = unconsume(tokenizerFuncBound, (res) => {
                // TODO: remove this
                return res;
              });
            }
          }
          if (arg.hooks) {
            const hooks = marked.options.hooks || new Hooks();
            for (const p in arg.hooks) {
              const hooksFunc = arg.hooks[p];
              const hooksFuncBound = hooksFunc.bind(hooks);
              hooks[p] = unconsume(hooksFuncBound, (res) => {
                // TODO: remove this
                return res;
              });
            }
          }
          if (arg.walkTokens) {
            marked.options.walkTokens = arg.walkTokens;
          }
        } else if (typeof arg === 'function') {
          // TODO: remove this
          marked.options.walkTokens = arg;
        }
      });

      marked.options.extensions = extensions;
      return marked;
    };
    marked.walkTokens = (tokens, callback) => {
      for (const token of tokens) {
        callback(token);
      }
    };
    marked.parse = marked;
    marked.Parser = Parser;
    marked.parser = Parser.parse;
    marked.Renderer = Renderer;
    marked.TextRenderer = TextRenderer;
    marked.Lexer = Lexer;

    marked.Tokenizer = Tokenizer;
    marked.Slugger = Slugger;
    marked.Hooks = Hooks;
    marked.parseInline = marked.parseInline;
    marked.defaults = defaultOptions;

    return marked;

}));

</code_block_to_apply_changes_from>
</rewritten_file>