<!doctype html>
<html lang="ja">
  <head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-8YNG8DGYKZ"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-8YNG8DGYKZ');
    </script>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="robots" content="noindex">
    <title>{% if is_edit %}スポットを編集 - {{ spot.name }}{% else %}新規スポット登録{% endif %} | maplink</title>
    <link rel="icon" type="image/png" href="{{ url_for('static', filename='images/favicon_32x32.png') }}">
    <link rel="apple-touch-icon" href="{{ url_for('static', filename='images/apple-touch-icon.png') }}">
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <script src="{{ url_for('static', filename='js/toast.js') }}"></script>
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
      integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
      crossorigin=""/>
    <!-- Leaflet JavaScript -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
      integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
      crossorigin=""></script>
    <!-- Leaflet Control Geocoder -->
    <!-- <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet-control-geocoder/2.4.0/Control.Geocoder.css" /> -->
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-control-geocoder/2.4.0/Control.Geocoder.js"></script> -->
    <style>
      /* 地図のスタイル */
      #location-map {
        width: 100%;
        height: 250px;
        border-radius: 0.75rem;
      }
      
      /* オートコンプリート用のスタイル */
      .autocomplete-container {
        position: relative;
      }
      
      .autocomplete-results {
        position: absolute;
        z-index: 1000;
        width: 100%;
        max-height: 200px;
        overflow-y: auto;
        background-color: white;
        border: 1px solid #ddd;
        border-radius: 0.75rem;
        margin-top: 4px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }
      
      .autocomplete-item {
        padding: 0.75rem 1rem;
        cursor: pointer;
        transition: background-color 0.2s;
      }
      
      .autocomplete-item:hover {
        background-color: #f3f4f6;
      }
      
      .hidden {
        display: none;
      }
      
      .loading-indicator {
        display: inline-block;
        width: 20px;
        height: 20px;
        border: 2px solid #f3f3f3;
        border-top: 2px solid #3498db;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        position: absolute;
        right: 10px;
        top: 50%;
        transform: translateY(-50%);
      }
      
      @keyframes spin {
        0% { transform: translateY(-50%) rotate(0deg); }
        100% { transform: translateY(-50%) rotate(360deg); }
      }
      
      .toggle-switch:checked + .toggle-slider {
        transform: translateX(20px);
      }
      .toggle-switch:checked ~ .toggle-bg {
        background-color: #3b82f6;
      }

      /* Accordion Styles */
      .accordion-header {
        cursor: pointer;
        display: flex;
        justify-content: space-between;
        align-items: center;
        background-color: #f9fafb; /* gray-50 */
        padding: 1rem;
        border-radius: 0.75rem;
        transition: background-color 0.2s;
      }
      .accordion-header:hover {
        background-color: #f3f4f6; /* gray-100 */
      }
      .accordion-icon {
        transition: transform 0.3s ease;
      }
      .accordion-content {
        max-height: 0;
        overflow: hidden;
        transition: max-height 0.3s ease-out;
        background-color: #f9fafb; /* gray-50 */
        border-radius: 0 0 0.75rem 0.75rem;
      }
      .accordion-content.open {
        padding: 1rem;
      }
    </style>
  </head>
  <body>
    <!-- スポットデータをdata属性として埋め込む -->
    <div id="spot-data" 
      data-is-edit="{% if is_edit %}true{% else %}false{% endif %}"
      data-latitude="{% if is_edit and spot.latitude %}{{ spot.latitude }}{% endif %}"
      data-longitude="{% if is_edit and spot.longitude %}{{ spot.longitude }}{% endif %}">
    </div>
    
    <div class="mx-auto w-full bg-white max-w-[480px]">
      <div class="overflow-hidden w-full bg-slate-50 min-h-[844px]">
        <!-- フラッシュメッセージ -->
        {% with messages = get_flashed_messages(with_categories=true) %}
          {% if messages %}
            {% for category, message in messages %}
              <div class="flask-flash-message hidden" data-category="{{ category }}">{{ message }}</div>
            {% endfor %}
          {% endif %}
        {% endwith %}
        
        <!-- Top Navigation -->
        <nav
          class="flex justify-between items-center px-4 pt-4 pb-2 w-full bg-slate-50"
        >
          <a
            href="{{ url_for('profile.mypage') }}"
            class="flex items-center self-stretch my-auto w-12 min-h-12"
            aria-label="Back"
          >
            <img
              src="https://cdn.builder.io/api/v1/image/assets/b8fa2d7a435f48ebab0c12e03b54941b/cbcfb374e6f9cf26c845989c39cf840095e94415ef262142766df01f141cd5e1?placeholderIfAbsent=true"
              alt="Back"
              class="object-contain self-stretch my-auto w-6 aspect-square"
            />
          </a>
          <h1
            class="flex-1 shrink self-stretch pr-12 my-auto text-lg font-bold leading-none text-center basis-0 min-w-60 text-neutral-900"
          >
            {% if is_edit %}スポットを編集{% else %}新規スポット登録{% endif %}
          </h1>
          {% if is_edit %}
          <button
            type="button"
            id="delete-spot-btn"
            class="flex items-center justify-center w-12 h-12 text-red-500 hover:text-red-600"
            aria-label="Delete spot"
          >
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M14.74 9l-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 01-2.244 2.077H8.084a2.25 2.25 0 01-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 00-3.478-.397m-12 .562c.34-.059.68-.114 1.022-.165m0 0a48.11 48.11 0 013.478-.397m7.5 0v-.916c0-1.18-.91-2.164-2.09-2.201a51.964 51.964 0 00-3.32 0c-1.18.037-2.09 1.022-2.09 2.201v.916m7.5 0a48.667 48.667 0 00-7.5 0" />
            </svg>
          </button>
          {% endif %}
        </nav>

        <!-- Tab Navigation (新規登録時のみ表示) -->
        {% if not is_edit %}
        <div class="flex w-full border-b border-gray-200 mb-4">
          <a href="{{ url_for('spot.add_spot') }}" 
             class="flex-1 py-2 px-4 text-center font-medium border-b-2 border-gray-600 text-gray-700">
            手動登録
          </a>
          <a href="{{ url_for('profile.import_management') }}" 
             class="flex-1 py-2 px-4 text-center font-medium text-gray-500 hover:text-gray-700">
            自動登録
          </a>
        </div>
        {% endif %}

        <!-- Spot Form -->
        <form 
          action="{% if is_edit %}{{ url_for('spot.edit_spot', spot_id=spot.id) }}{% else %}{{ url_for('spot.add_spot') }}{% endif %}" 
          method="POST" 
          enctype="multipart/form-data"
          class="flex flex-col gap-6 p-4 w-full"
        >
          <input type="hidden" name="csrf_token" value="{{ csrf_token() }}">
          
          <!-- 緯度経度の隠しフィールド -->
          <input type="hidden" id="latitude" name="latitude" value="{% if is_edit %}{{ spot.latitude or '' }}{% endif %}">
          <input type="hidden" id="longitude" name="longitude" value="{% if is_edit %}{{ spot.longitude or '' }}{% endif %}">
          <input type="hidden" id="google_place_id" name="google_place_id" value="{% if is_edit %}{{ spot.google_place_id or '' }}{% endif %}">
          <input type="hidden" id="formatted_address" name="formatted_address" value="{% if is_edit %}{{ spot.formatted_address or '' }}{% endif %}">
          <input type="hidden" id="types" name="types" value="{% if is_edit %}{{ spot.types or '' }}{% endif %}">
          <input type="hidden" id="thumbnail_url" name="thumbnail_url" value="{% if is_edit %}{{ spot.thumbnail_url or '' }}{% endif %}">
          <input type="hidden" id="summary_location" name="summary_location" value="{% if is_edit %}{{ spot.summary_location or '' }}{% endif %}">
          <!-- Spot Name -->
          <div class="flex flex-col gap-2 w-full">
            <label for="spotName" class="text-sm font-bold text-neutral-900">スポット名</label>
            <div class="autocomplete-container">
              <input
                type="text"
                id="spotName"
                name="spotName"
                required
                value="{% if is_edit %}{{ spot.name }}{% endif %}"
                placeholder="スポット名を入力"
                class="px-4 py-3 w-full text-base bg-white rounded-xl border border-slate-300 focus:outline-none focus:ring-2 focus:ring-blue-500"
                autocomplete="off"
              />
              <div id="loading-indicator" class="loading-indicator hidden"></div>
              <div id="autocomplete-results" class="autocomplete-results hidden"></div>
            </div>
          </div>

          <!-- Spot Location -->
          <div class="flex flex-col gap-2 w-full">
            <label for="location" class="text-sm font-bold text-neutral-900">住所</label>
            <input
              type="text"
              id="location"
              name="location"
              value="{% if is_edit %}{{ spot.location }}{% endif %}"
              placeholder="住所を入力"
              class="px-4 py-3 w-full text-base bg-white rounded-xl border border-slate-300 focus:outline-none focus:ring-2 focus:ring-blue-500"
            />
          </div>

          <!-- Location Map -->
          <div class="flex flex-col gap-2 w-full">
            <label class="text-sm font-bold text-neutral-900">地図上の位置</label>
            <p class="text-xs text-slate-500 mb-2">地図をクリックして位置を設定するか、マーカーをドラッグして位置を調整してください。</p>
            <div id="location-map" class="w-full rounded-xl"></div>
          </div>

          <!-- Spot Category -->
          <div class="flex flex-col gap-2 w-full">
            <label for="category" class="text-sm font-bold text-neutral-900">カテゴリー</label>
            <div class="autocomplete-container relative" style="z-index: 9999;">
              <input
                type="text"
                id="category"
                name="category"
                value="{% if is_edit %}{{ spot.category }}{% endif %}"
                placeholder="カテゴリーを入力または選択"
                class="px-4 py-3 w-full text-base bg-white rounded-xl border border-slate-300 focus:outline-none focus:ring-2 focus:ring-blue-500"
                autocomplete="off"
              />
              <div id="category-loading-indicator" class="loading-indicator hidden"></div>
              <div id="category-autocomplete-results" class="autocomplete-results hidden absolute z-[9999] w-full bg-white border border-gray-200 rounded-xl shadow-lg mt-1 max-h-60 overflow-y-auto"></div>
            </div>
            <p class="text-xs text-slate-500">新しいカテゴリーを入力するか、過去のカテゴリーから選択してください</p>
          </div>

          <!-- Rating -->
          <div class="flex flex-col gap-2 w-full">
            <label class="text-sm font-bold text-neutral-900">評価</label>
            <div class="rating-stars flex items-center gap-1"
                 x-data="{
                   rating: {{ '0' if not is_edit else spot.rating or '0' }},
                   hoverRating: 0,
                   setRating(star, event) {
                     const target = event.currentTarget;
                     const isHalf = (event.offsetX / target.clientWidth) < 0.5;
                     this.rating = isHalf ? star - 0.5 : star;
                   },
                   setHoverRating(star, event) {
                     if (event) {
                       const target = event.currentTarget;
                       const isHalf = (event.offsetX / target.clientWidth) < 0.5;
                       this.hoverRating = isHalf ? star - 0.5 : star;
                     } else {
                       this.hoverRating = 0;
                     }
                   },
                   getStarFill(star) {
                     const R = this.hoverRating || this.rating;
                     if (R >= star) return '100%';
                     if (R > star - 1) return `${(R - (star - 1)) * 100}%`;
                     return '0%';
                   }
                 }"
                 @mouseleave="setHoverRating(0, null)">
              <input type="hidden" id="rating" name="rating" x-model="rating">
              <template x-for="star in 5" :key="star">
                <div class="relative inline-block cursor-pointer text-3xl text-gray-300"
                     @mousemove="setHoverRating(star, $event)"
                     @click="setRating(star, $event)">
                  <!-- background star (always gray) -->
                  <span>★</span>
                  <!-- foreground star (amber, clipped) -->
                  <div class="absolute top-0 left-0 h-full overflow-hidden text-amber-400" :style="{ width: getStarFill(star) }">
                    <span>★</span>
                  </div>
                </div>
              </template>
            </div>
            <p class="text-xs text-slate-500">星をクリックして評価を設定してください</p>
          </div>

          <!-- Spot Description -->
          <div class="flex flex-col gap-2 w-full">
            <label for="description" class="text-sm font-bold text-neutral-900">説明</label>
            <textarea
              id="description"
              name="description"
              rows="4"
              placeholder="スポットの説明を入力"
              class="px-4 py-3 w-full text-base bg-white rounded-xl border border-slate-300 focus:outline-none focus:ring-2 focus:ring-blue-500"
            >{{ spot.description if is_edit else '' }}</textarea>
          </div>

          <!-- Photos -->
          <div class="flex flex-col gap-2 w-full">
            <label class="text-sm font-bold text-neutral-900">{% if is_edit %}新しい写真を追加{% else %}写真{% endif %}</label>
            <div class="flex flex-col gap-3 w-full">
              <div class="relative">
                <input
                  type="file"
                  id="photos"
                  name="photos"
                  multiple
                  accept="image/*"
                  class="absolute inset-0 w-full h-full opacity-0 cursor-pointer"
                />
                <div
                  class="flex justify-center items-center px-4 py-3 w-full bg-white rounded-xl border border-dashed border-slate-300 min-h-[100px]"
                  id="drop-area"
                >
                  <div class="flex flex-col items-center text-center">
                    <svg
                      xmlns="http://www.w3.org/2000/svg"
                      fill="none"
                      viewBox="0 0 24 24"
                      stroke-width="1.5"
                      stroke="currentColor"
                      class="w-8 h-8 text-slate-400 mb-2"
                    >
                      <path
                        stroke-linecap="round"
                        stroke-linejoin="round"
                        d="M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5m-13.5-9L12 3m0 0l4.5 4.5M12 3v13.5"
                      />
                    </svg>
                    <p class="text-sm text-slate-500">
                      写真をドラッグ＆ドロップまたは<span class="text-blue-500">ファイルを選択</span>
                    </p>
                    <p class="text-xs text-slate-400 mt-1">
                      ※ 1枚あたり10MB以下のJPG、PNG、GIF形式
                    </p>
                  </div>
                </div>
              </div>
              <div
                id="photo-preview-container"
                class="grid grid-cols-3 gap-4"
              ></div>
            </div>
          </div>
          
          <!-- Optional Settings Accordion -->
          <div class="flex flex-col gap-2 w-full" x-data="{ open: false }">
            <!-- Accordion Header -->
            <div @click="open = !open" class="flex items-center justify-between w-full cursor-pointer">
              <label class="text-sm font-bold text-neutral-900">オプション設定</label>
              <span class="transform transition-transform duration-200" :class="{'rotate-180': open}">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-slate-500" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" /></svg>
              </span>
            </div>
            
            <!-- Accordion Content -->
            <div x-show="open" x-transition class="w-full">
              <div class="flex flex-col gap-4 pt-4">
                <!-- SNS Links -->
                <div class="flex flex-col gap-4 w-full p-4 bg-slate-50 rounded-xl">
                  <h3 class="text-sm font-bold text-neutral-900">SNS投稿の関連付け</h3>
                  {% set social_platforms = {
                    'instagram': 'Instagramの投稿URL',
                    'tiktok': 'TikTokの投稿URL',
                    'twitter': 'Twitterの投稿URL',
                    'youtube': 'YouTubeの動画URL'
                  } %}
                  
                  {% set spot_social_links = {} %}
                  {% if is_edit and spot.social_posts %}
                    {% for post in spot.social_posts %}
                      {% if post.platform in social_platforms %}
                        {% set _ = spot_social_links.update({post.platform: post.post_url}) %}
                      {% endif %}
                    {% endfor %}
                  {% endif %}

                  {% for platform, placeholder in social_platforms.items() %}
                  <div class="flex flex-col gap-1.5 w-full">
                    <label for="{{ platform }}_url" class="text-sm font-medium text-neutral-600">{{ platform|title }}</label>
                    <input
                      type="url"
                      id="{{ platform }}_url"
                      name="{{ platform }}_url"
                      value="{{ spot_social_links.get(platform, '') }}"
                      placeholder="{{ placeholder }}"
                      class="px-4 py-2.5 w-full text-base bg-white rounded-lg border border-slate-300 focus:outline-none focus:ring-2 focus:ring-blue-500"
                    />
                  </div>
                  {% endfor %}
                </div>
                
                <!-- Custom Links Data (隠し要素) -->
                <script type="application/json" id="custom-links-data">
{{ custom_links|tojson|safe if is_edit else '[]' }}
                </script>
                
                <!-- Affiliate Links -->
                <div class="flex flex-col gap-4 w-full p-4 bg-slate-50 rounded-xl"
                     x-data="{
                       otherLinks: (() => {
                         try {
                           const dataElement = document.getElementById('custom-links-data');
                           return dataElement ? JSON.parse(dataElement.textContent) : [];
                         } catch (error) {
                           console.error('Custom links data parse error:', error);
                           return [];
                         }
                       })(),
                       addLink() {
                         this.otherLinks.push({ id: null, title: '', url: '' });
                       },
                       removeLink(index) {
                         this.otherLinks.splice(index, 1);
                       }
                     }">
                  <h3 class="text-sm font-bold text-neutral-900">予約・アフィリエイトリンク</h3>
                  
                  <!-- Rakuten Link (Fixed) -->
                  <div class="flex flex-col gap-1.5">
                    <label for="rakuten_url" class="text-sm font-medium text-neutral-600">楽天トラベル URL</label>
                    <input type="url" id="rakuten_url" name="rakuten_url" value="{{ rakuten_link.url if rakuten_link else '' }}" placeholder="楽天トラベルのURL" class="px-4 py-2.5 w-full text-base bg-white rounded-lg border border-slate-300 focus:outline-none focus:ring-2 focus:ring-blue-500">
                  </div>
                  
                  {% if current_user.rakuten_affiliate_id %}
                    <p class="text-xs text-slate-500 mt-1">
                      <a href="{{ url_for('profile.affiliate_settings') }}" class="text-blue-500 hover:underline">アフィリエイトID設定済み</a>: この項目が空の場合、スポット名に一致するホテルを自動で検索し、アフィリエイトリンクを生成します。
                    </p>
                  {% else %}
                    <p class="text-xs text-slate-500 mt-1">
                      楽天アフィリエイトIDをお持ちの場合は、<a href="{{ url_for('profile.affiliate_settings') }}" class="text-blue-500 hover:underline">アフィリエイト設定</a>から登録すると、URLが空の場合にリンクが自動生成されます。
                    </p>
                  {% endif %}

                  <!-- Divider -->
                  <hr class="border-t border-slate-200 my-2">

                  <!-- Other Links Section -->
                  <h4 class="text-sm font-bold text-neutral-900">その他のリンク</h4>
                  <div class="flex flex-col gap-4">
                    <template x-for="(link, index) in otherLinks" :key="index">
                      <div class="flex flex-col gap-3 p-3 bg-white rounded-lg border border-slate-200">
                        <input type="hidden" :name="'other_links[' + index + '][id]'" x-model="link.id">
                        <div class="flex flex-col gap-1.5">
                          <label :for="'other_link_title_' + index" class="text-sm font-medium text-neutral-600">サイト名</label>
                          <input type="text" :id="'other_link_title_' + index" :name="'other_links[' + index + '][title]'" x-model="link.title" placeholder="例: 公式サイト" class="px-4 py-2.5 w-full text-base bg-white rounded-lg border border-slate-300 focus:outline-none focus:ring-2 focus:ring-blue-500">
                        </div>
                        <div class="flex flex-col gap-1.5">
                          <label :for="'other_link_url_' + index" class="text-sm font-medium text-neutral-600">URL</label>
                          <input type="url" :id="'other_link_url_' + index" :name="'other_links[' + index + '][url]'" x-model="link.url" placeholder="https://..." class="px-4 py-2.5 w-full text-base bg-white rounded-lg border border-slate-300 focus:outline-none focus:ring-2 focus:ring-blue-500">
                        </div>
                        <button type="button" @click="removeLink(index)" class="text-sm text-red-500 hover:text-red-700 self-end">削除</button>
                      </div>
                    </template>
                  </div>
                  <button type="button" @click="addLink()" class="flex items-center justify-center gap-2 px-4 py-2 text-sm font-medium text-blue-600 bg-blue-50 rounded-lg hover:bg-blue-100">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z" clip-rule="evenodd" /></svg>
                    リンクを追加
                  </button>

                </div>
              </div>
            </div>
          </div>

          <!-- is_active Toggle -->
          <div class="flex items-center justify-between w-full">
            <div class="flex flex-col flex-1">
              <label for="is_active" class="text-sm font-medium text-slate-700">表示設定</label>
              <p class="text-xs text-slate-500 mt-1">このスポットをマイページに表示する</p>
            </div>
            <label
              class="flex p-0.5 rounded-2xl bg-slate-200 min-h-[31px] w-[51px] cursor-pointer toggle-bg transition-colors duration-200 {% if not is_edit or (is_edit and spot.is_active) %}bg-blue-500{% endif %}"
              role="switch"
              id="is-active-toggle-bg"
            >
              <input type="checkbox" name="is_active" id="is_active" class="toggle-switch sr-only" {% if not is_edit or (is_edit and spot.is_active) %}checked{% endif %} />
              <span
                class="toggle-slider flex bg-white rounded-2xl h-[27px] min-h-[27px] shadow-[0px_3px_8px_rgba(0,0,0,0.15)] w-[27px] transition-all duration-200"
              ></span>
            </label>
          </div>

          <!-- Submit Button -->
          <button
            type="submit"
            class="flex justify-center items-center px-4 w-full bg-blue-500 text-white rounded-xl min-h-12 mt-4"
          >
            <span class="text-base font-medium">{% if is_edit %}変更を保存{% else %}スポットを登録{% endif %}</span>
          </button>
        </form>
      </div>
    </div>

    <style>
      .toggle-switch:checked + .toggle-slider {
        transform: translateX(20px);
      }
      .toggle-switch:checked ~ .toggle-bg {
        background-color: #3b82f6;
      }
      .preview-item {
        position: relative;
        width: 80px;
        height: 80px;
      }
      .preview-item img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        border-radius: 8px;
      }
      .remove-btn {
        position: absolute;
        top: -8px;
        right: -8px;
        background: #ef4444;
        color: white;
        border-radius: 50%;
        width: 20px;
        height: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        cursor: pointer;
      }
      /* モーダル表示時のスタイル */
      body.modal-open {
        overflow: hidden;
      }
      
      body.modal-open .leaflet-container {
        z-index: 1 !important;
      }
      
      body.modal-open .autocomplete-container {
        z-index: 1 !important;
      }
      
      .autocomplete-container {
        position: relative;
        z-index: 1000;
      }
      
      #location-map {
        z-index: 1;
      }
    </style>

    <!-- 地図ユーティリティJSの読み込み -->
    <script src="{{ url_for('static', filename='js/map-utils.js') }}"></script>

    <!-- 削除確認モーダル -->
    <div id="delete-confirm-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-[10000]">
      <div class="bg-white rounded-xl p-6 max-w-sm w-full mx-4">
        <h3 class="text-lg font-bold text-neutral-900 mb-4">スポットを削除</h3>
        <p class="text-neutral-600 mb-6">このスポットを削除してもよろしいですか？この操作は取り消せません。</p>
        <div class="flex justify-end gap-4">
          <button
            type="button"
            id="cancel-delete-btn"
            class="px-4 py-2 text-neutral-600 hover:bg-neutral-100 rounded-lg"
          >
            キャンセル
          </button>
          <form
            action="{{ url_for('spot.delete_spot', spot_id=spot.id) if is_edit else '#' }}"
            method="POST"
            id="delete-spot-form"
          >
            <input type="hidden" name="csrf_token" value="{{ csrf_token() }}">
            <button
              type="submit"
              class="px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600"
            >
              削除する
            </button>
          </form>
        </div>
      </div>
    </div>

    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
    <script>
      // グローバルエラーハンドリング
      window.addEventListener('error', function(event) {
        console.error('Global error caught:', event.error);
        alert('ページの読み込み中にエラーが発生しました。ページをリロードしてください。');
      });

      document.addEventListener('DOMContentLoaded', function() {
        // グローバル変数として地図とマーカーを定義
        let globalMap = null;
        let globalMarker = null;

        // トグルスイッチの挙動を設定
        const isActiveToggleSwitch = document.getElementById('is_active');
        const isActiveToggleBg = document.getElementById('is-active-toggle-bg');
        if (isActiveToggleSwitch && isActiveToggleBg) {
          const updateToggleState = () => {
            if (isActiveToggleSwitch.checked) {
              isActiveToggleBg.classList.remove('bg-slate-200');
              isActiveToggleBg.classList.add('bg-blue-500');
            } else {
              isActiveToggleBg.classList.remove('bg-blue-500');
              isActiveToggleBg.classList.add('bg-slate-200');
            }
          };
          updateToggleState();
          isActiveToggleSwitch.addEventListener('change', updateToggleState);
        }

        // File upload preview
        const fileInput = document.getElementById('photos');
        const previewContainer = document.getElementById('photo-preview-container');
        const dropArea = document.getElementById('drop-area');
        
        if(fileInput && previewContainer && dropArea) {
          const handleFiles = () => {
            const files = fileInput.files;
            const maxSizePerFile = 10 * 1024 * 1024; // 10MB
            let hasError = false;
            
            previewContainer.innerHTML = ''; // Clear previous previews

            for (let i = 0; i < files.length; i++) {
              const file = files[i];
              if (!file.type.startsWith('image/')) {
                maplinkToast.error(`${file.name} は画像ファイルではありません。`);
                hasError = true;
                continue;
              }
              if (file.size > maxSizePerFile) {
                maplinkToast.error(`${file.name} のサイズが大きすぎます（10MB以下）。`);
                hasError = true;
                continue;
              }
              
              const reader = new FileReader();
              reader.onload = function(e) {
                const previewItem = document.createElement('div');
                previewItem.className = 'preview-item';
                const img = document.createElement('img');
                img.src = e.target.result;
                img.alt = 'Preview';
                const removeBtn = document.createElement('div');
                removeBtn.className = 'remove-btn';
                removeBtn.innerHTML = '×';
                removeBtn.onclick = () => {
                  // This is a simplified removal. For a better UX, you'd manage a FileList object.
                  previewItem.remove();
                };
                previewItem.appendChild(img);
                previewItem.appendChild(removeBtn);
                previewContainer.appendChild(previewItem);
              };
              reader.readAsDataURL(file);
            }
            if (hasError) {
              fileInput.value = ''; 
              previewContainer.innerHTML = '';
            }
          }

          fileInput.addEventListener('change', handleFiles);
          dropArea.addEventListener('dragover', (e) => { e.preventDefault(); dropArea.classList.add('border-blue-500'); });
          dropArea.addEventListener('dragleave', () => { dropArea.classList.remove('border-blue-500'); });
          dropArea.addEventListener('drop', (e) => {
            e.preventDefault();
            dropArea.classList.remove('border-blue-500');
            if (e.dataTransfer.files.length) {
              fileInput.files = e.dataTransfer.files;
              handleFiles();
            }
          });
        }
        
        // Remove existing photo functionality
        document.querySelectorAll('.remove-btn[data-photo-id]').forEach(btn => {
          btn.addEventListener('click', function() {
            const photoId = this.dataset.photoId;
            const previewItem = this.closest('.preview-item');
            const deleteInput = document.createElement('input');
            deleteInput.type = 'hidden';
            deleteInput.name = 'delete_photos';
            deleteInput.value = photoId;
            document.querySelector('form').appendChild(deleteInput);
            previewItem.style.display = 'none';
          });
        });

        // 地図とオートコンプリートの初期化
        try {
          const spotNameInput = document.getElementById('spotName');
          const autocompleteResults = document.getElementById('autocomplete-results');
          const loadingIndicator = document.getElementById('loading-indicator');
          const locationInput = document.getElementById('location');
          const latitudeInput = document.getElementById('latitude');
          const longitudeInput = document.getElementById('longitude');
          const googlePlaceIdInput = document.getElementById('google_place_id');
          const formattedAddressInput = document.getElementById('formatted_address');
          const typesInput = document.getElementById('types');
          const thumbnailUrlInput = document.getElementById('thumbnail_url');
          
          let initialLat = 35.6812, initialLng = 139.7671, initialZoom = 13;
          
          const spotDataElement = document.getElementById('spot-data');
          const isEdit = spotDataElement.dataset.isEdit === 'true';
          const spotLat = spotDataElement.dataset.latitude ? parseFloat(spotDataElement.dataset.latitude) : null;
          const spotLng = spotDataElement.dataset.longitude ? parseFloat(spotDataElement.dataset.longitude) : null;
          
          if (isEdit && spotLat && spotLng) {
            initialLat = spotLat;
            initialLng = spotLng;
            initialZoom = 15;
          }
          
          if (typeof initMap === 'function') {
            globalMap = initMap('location-map', { center: [initialLat, initialLng], zoom: initialZoom });
            
            if (latitudeInput.value && longitudeInput.value) {
              globalMarker = addMarker(globalMap, parseFloat(latitudeInput.value), parseFloat(longitudeInput.value), { draggable: true });
              globalMarker.on('dragend', function(e) {
                const latlng = e.target.getLatLng();
                updateInputs(latlng.lat, latlng.lng);
                reverseGeocode(latlng.lat, latlng.lng).then(result => {
                  if (result) {
                    locationInput.value = result.address;
                    document.getElementById('summary_location').value = result.summary_location;
                  }
                });
              });
            }
            
            globalMap.on('click', function(e) {
              const latlng = e.latlng;
              updateMarkerAndInputs(latlng.lat, latlng.lng);
              reverseGeocode(latlng.lat, latlng.lng).then(result => {
                if (result) {
                  locationInput.value = result.address;
                  document.getElementById('summary_location').value = result.summary_location;
                }
              });
            });
          }
          
          function updateInputs(lat, lng) {
            latitudeInput.value = lat;
            longitudeInput.value = lng;
          }
          
          function updateMarkerAndInputs(lat, lng, address = null) {
            updateInputs(lat, lng);
            if (address) locationInput.value = address;
            if (globalMarker) {
              globalMarker.setLatLng([lat, lng]);
            } else {
              globalMarker = addMarker(globalMap, lat, lng, { draggable: true });
              globalMarker.on('dragend', function(e) {
                const latlng = e.target.getLatLng();
                updateInputs(latlng.lat, latlng.lng);
                reverseGeocode(latlng.lat, latlng.lng).then(result => {
                  if (result) {
                    locationInput.value = result.address;
                    document.getElementById('summary_location').value = result.summary_location;
                  }
                });
              });
            }
          }
          
          let timeout = null;
          spotNameInput.addEventListener('input', function() {
            const query = this.value.trim();
            loadingIndicator.classList.remove('hidden');
            clearTimeout(timeout);
            timeout = setTimeout(() => {
              if (query.length >= 2) {
                fetch(`/api/places/autocomplete?query=${encodeURIComponent(query)}`)
                  .then(response => response.json())
                  .then(suggestions => {
                    loadingIndicator.classList.add('hidden');
                    displaySuggestions(suggestions);
                  })
                  .catch(error => {
                    console.error('Error fetching suggestions:', error);
                    loadingIndicator.classList.add('hidden');
                  });
              } else {
                loadingIndicator.classList.add('hidden');
                autocompleteResults.classList.add('hidden');
              }
            }, 300);
          });
          
          function displaySuggestions(suggestions) {
            autocompleteResults.innerHTML = '';
            if (suggestions.length === 0) {
              autocompleteResults.classList.add('hidden');
              return;
            }
            suggestions.forEach(suggestion => {
              const item = document.createElement('div');
              item.className = 'autocomplete-item';
              item.innerHTML = `
                <div class="font-medium">${suggestion.description}</div>
                <div class="text-sm text-gray-500">${suggestion.secondary_text || ''}</div>
              `;
              item.addEventListener('click', () => {
                selectPlace(suggestion.place_id);
                autocompleteResults.classList.add('hidden');
                locationInput.focus();
              });
              autocompleteResults.appendChild(item);
            });
            autocompleteResults.classList.remove('hidden');
          }
          
          function selectPlace(placeId) {
            loadingIndicator.classList.remove('hidden');
            fetch(`/api/places/details?place_id=${placeId}`)
              .then(response => response.json())
              .then(data => {
                loadingIndicator.classList.add('hidden');
                spotNameInput.value = data.name;
                locationInput.value = data.formatted_address;
                latitudeInput.value = data.latitude;
                longitudeInput.value = data.longitude;
                googlePlaceIdInput.value = data.place_id;
                formattedAddressInput.value = data.formatted_address;
                if (data.summary_location) document.getElementById('summary_location').value = data.summary_location;
                if (data.types && data.types.length > 0) typesInput.value = JSON.stringify(data.types);
                if (data.thumbnail_url) thumbnailUrlInput.value = data.thumbnail_url;
                
                if (globalMap && data.latitude && data.longitude) {
                  updateMarkerAndInputs(data.latitude, data.longitude);
                  globalMap.setView([data.latitude, data.longitude], 15);
                }
                autocompleteResults.classList.add('hidden');
              })
              .catch(error => {
                console.error('Error fetching place details:', error);
                loadingIndicator.classList.add('hidden');
              });
          }
          
          document.addEventListener('click', function(e) {
            if (!autocompleteResults.contains(e.target) && e.target !== spotNameInput) {
              autocompleteResults.classList.add('hidden');
            }
          });
          
        } catch (error) {
          console.error('Error initializing map and autocomplete:', error);
        }

        // カテゴリの自動補完機能
        try {
          const categoryInput = document.getElementById('category');
          const categoryResults = document.getElementById('category-autocomplete-results');
          
          fetch('/api/user/categories')
            .then(response => response.json())
            .then(categories => {
              const showCategorySuggestions = (query = '') => {
                const filtered = categories.filter(c => c.toLowerCase().includes(query.toLowerCase()));
                categoryResults.innerHTML = '';
                if (filtered.length > 0) {
                  filtered.forEach(category => {
                    const item = document.createElement('div');
                    item.className = 'autocomplete-item';
                    item.textContent = category;
                    item.addEventListener('click', () => {
                      categoryInput.value = category;
                      categoryResults.classList.add('hidden');
                      document.getElementById('description').focus();
                    });
                    categoryResults.appendChild(item);
                  });
                  categoryResults.classList.remove('hidden');
                } else {
                  categoryResults.classList.add('hidden');
                }
              };
              
              categoryInput.addEventListener('focus', () => showCategorySuggestions(categoryInput.value));
              categoryInput.addEventListener('input', () => showCategorySuggestions(categoryInput.value));
              
              document.addEventListener('click', function(e) {
                if (!categoryResults.contains(e.target) && e.target !== categoryInput) {
                  categoryResults.classList.add('hidden');
                }
              });
            })
            .catch(error => console.error('Error fetching categories:', error));
        } catch(error) {
          console.error('Error setting up category autocomplete:', error);
        }

        // 削除機能の実装
        const deleteBtn = document.getElementById('delete-spot-btn');
        const modal = document.getElementById('delete-confirm-modal');
        const cancelBtn = document.getElementById('cancel-delete-btn');
        if (deleteBtn && modal && cancelBtn) {
          deleteBtn.addEventListener('click', () => { modal.classList.remove('hidden'); document.body.classList.add('modal-open'); });
          cancelBtn.addEventListener('click', () => { modal.classList.add('hidden'); document.body.classList.remove('modal-open'); });
          modal.addEventListener('click', (e) => { 
            if (e.target === modal) {
              modal.classList.add('hidden'); document.body.classList.remove('modal-open');
            }
          });
        }
      });
    </script>
  </body>
</html> 